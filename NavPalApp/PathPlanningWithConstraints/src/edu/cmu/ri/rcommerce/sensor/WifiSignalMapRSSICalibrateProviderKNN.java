package edu.cmu.ri.rcommerce.sensor;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import edu.cmu.ri.rcommerce.particleFilter.Particle2D;

/** Stores a map of wifi signal strengths over space, which can be queried for the signal strengths expected at any point.
 * Returns a reading generated by interpolating among the 'k' nearest
 * @author Nisarg
 */
public class WifiSignalMapRSSICalibrateProviderKNN implements RSSICalibrateProvider<Particle2D> {
	List<CorrelatedSignalValues> data;
	int k;
	public WifiSignalMapRSSICalibrateProviderKNN(BufferedReader input,int k) throws IOException {
		data = new ArrayList<CorrelatedSignalValues>();
		this.k = k;
		while(true)
		{
			String line = input.readLine();
			if (line == null)
				break;
			data.add(CorrelatedSignalValues.fromString(line));
			
		}
		if (data.size() == 0)
			throw new IOException("error reading signal strength dump");
	}
	@Override
	public List<RSSIReading> getExpectedReadings(Particle2D particle) {
		Collections.sort(data,new DistanceToPointComparator(particle.x,particle.y));
		
		List<RSSIReading> neighbors = new ArrayList<RSSIReading>();
		for (int i = 0 ; i<k ; i++)
			neighbors.add(data.get(i).toRSSIReadingWifi());
		
		return neighbors;
	}
	
	
	@Override
	public float getDistanceToNearestCalibrationPoint(Particle2D particle) {
		double minDistance = Double.MAX_VALUE;
		for (CorrelatedSignalValues v : data)
		{
			double distanceSquared = distanceSquared(v.x, v.y, particle.x, particle.y);
			if ( distanceSquared< minDistance)
			{
				minDistance = distanceSquared;
			}
		}
		return (float) Math.sqrt(minDistance);
	}
	
	double distanceSquared(double x1,double y1,double x2,double y2)
	{
		return Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2);
	}
	

}
